name: Deploy to ECS

on:
  push:
    branches:
      - master

jobs:
  deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Check out code
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Log in to Amazon ECR
        run: aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 454626435046.dkr.ecr.us-east-1.amazonaws.com

      - name: Build and Push Docker image
        run: |
          IMAGE_NAME="454626435046.dkr.ecr.us-east-1.amazonaws.com/threatened-species"
          docker build -t threatened-species .
          docker tag threatened-species:latest $IMAGE_NAME:latest
          docker push $IMAGE_NAME:latest

      - name: Update ECS Service
        run: |
          # Task definition family name in ECS
          TASK_FAMILY="my-ecs-task"

          # 1) Pull the existing task definition JSON
          TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition "$TASK_FAMILY" --query "taskDefinition" --output json)

          # 2) Extract container definitions
          CONTAINER_DEFINITIONS=$(echo "$TASK_DEFINITION" | jq '.containerDefinitions')

          # 3) Update the image URI for container "threatened-species"
          NEW_CONTAINER_DEFINITIONS=$(echo "$CONTAINER_DEFINITIONS" | jq --arg IMAGE_NAME "$IMAGE_NAME:latest" '
            map(if .name == "threatened-species" then .image = $IMAGE_NAME else . end)
          ')

          # 4) Extract other needed fields
          EXECUTION_ROLE_ARN="arn:aws:iam::454626435046:role/LabRole"
          TASK_ROLE_ARN=$(echo "$TASK_DEFINITION" | jq -r '.taskRoleArn')
          CPU=$(echo "$TASK_DEFINITION" | jq -r '.cpu')
          MEMORY=$(echo "$TASK_DEFINITION" | jq -r '.memory')
          NETWORK_MODE=$(echo "$TASK_DEFINITION" | jq -r '.networkMode')
          REQUIRES_COMPAT=$(echo "$TASK_DEFINITION" | jq -r '.requiresCompatibilities | join(" ")')

          # Some older task defs won't have runtimePlatform at all; handle gracefully
          RUNTIME_PLATFORM=$(echo "$TASK_DEFINITION" | jq -r '.runtimePlatform // empty')

          # 5) Create the new task definition JSON file
          cat <<EOF > task-def.json
          {
            "family": "$TASK_FAMILY",
            "executionRoleArn": "$EXECUTION_ROLE_ARN",
            "taskRoleArn": "$TASK_ROLE_ARN",
            "cpu": "$CPU",
            "memory": "$MEMORY",
            "networkMode": "$NETWORK_MODE",
            "requiresCompatibilities": ["$REQUIRES_COMPAT"],
            "containerDefinitions": $NEW_CONTAINER_DEFINITIONS
          }
          EOF

          # 6) If runtimePlatform exists, add it to the JSON
          if [ -n "$RUNTIME_PLATFORM" ] && [ "$RUNTIME_PLATFORM" != "null" ]; then
            jq --argjson platform "$RUNTIME_PLATFORM" '. + {runtimePlatform: $platform}' task-def.json > tmp.json && mv tmp.json task-def.json
          fi

          # 7) Register the new task definition
          NEW_TASK_DEF=$(aws ecs register-task-definition --cli-input-json file://task-def.json)
          NEW_REVISION=$(echo "$NEW_TASK_DEF" | jq -r '.taskDefinition.revision')

          echo "New task definition revision: $NEW_REVISION"

          # 8) Update the ECS service to use the new revision
          aws ecs update-service \
            --cluster threatened-species-cluster \
            --service threatened-species-service \
            --task-definition "${TASK_FAMILY}:${NEW_REVISION}" \
            --force-new-deployment

          echo "Service updated to use task definition revision ${NEW_REVISION}."

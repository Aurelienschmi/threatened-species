name: Deploy to ECS

on:
  push:
    branches:
      - master

jobs:
  deploy:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Check out code
        uses: actions/checkout@v3
      
      - name: Configure AWS Credentials (Secrets)
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1
      
      - name: Log in to Amazon ECR
        run: aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 454626435046.dkr.ecr.us-east-1.amazonaws.com

      - name: Build and Push Docker image
        run: |
          IMAGE_NAME="454626435046.dkr.ecr.us-east-1.amazonaws.com/threatened-species"
          docker build -t threatened-species .
          docker tag threatened-species:latest $IMAGE_NAME:latest
          docker push $IMAGE_NAME:latest

      - name: Update ECS Service
        run: |
          # Task definition family name in ECS (e.g., "my-ecs-task")
          TASK_FAMILY="my-ecs-task"

          # 1) Pull the existing task definition JSON
          TASK_DEFINITION=$(aws ecs describe-task-definition --task-definition "$TASK_FAMILY")

          # 2) Extract container definitions
          CONTAINER_DEFINITIONS=$(echo "$TASK_DEFINITION" | jq -r '.taskDefinition.containerDefinitions')

          # 3) Replace the image URI in the container named "threatened-species"
          #    (if your container name differs, adjust accordingly)
          NEW_CONTAINER_DEFINITIONS=$(echo "$CONTAINER_DEFINITIONS" | jq 'map(
            if .name == "threatened-species" 
            then .image = "'$IMAGE_NAME':latest" 
            else . end
          )')

          # 4) Extract other needed fields
          EXECUTION_ROLE_ARN=$(echo "$TASK_DEFINITION" | jq -r '.taskDefinition.executionRoleArn')
          TASK_ROLE_ARN=$(echo "$TASK_DEFINITION" | jq -r '.taskDefinition.taskRoleArn')
          CPU=$(echo "$TASK_DEFINITION" | jq -r '.taskDefinition.cpu')
          MEMORY=$(echo "$TASK_DEFINITION" | jq -r '.taskDefinition.memory')
          NETWORK_MODE=$(echo "$TASK_DEFINITION" | jq -r '.taskDefinition.networkMode')
          REQUIRES_COMPAT=$(echo "$TASK_DEFINITION" | jq -r '.taskDefinition.requiresCompatibilities | join(" ")')
          
          # Some older task defs won't have runtimePlatform at all; handle gracefully
          RUNTIME_PLATFORM=$(echo "$TASK_DEFINITION" | jq -r '.taskDefinition.runtimePlatform // empty')

          # 5) Build our register-task-definition args
          REGISTER_ARGS="--family $TASK_FAMILY \
            --execution-role-arn $EXECUTION_ROLE_ARN \
            --task-role-arn $TASK_ROLE_ARN \
            --cpu $CPU \
            --memory $MEMORY \
            --network-mode $NETWORK_MODE \
            --requires-compatibilities $REQUIRES_COMPAT \
            --container-definitions '$NEW_CONTAINER_DEFINITIONS'"

          # Only add runtimePlatform if it's non-empty (avoid "null" errors)
          if [ -n "$RUNTIME_PLATFORM" ] && [ "$RUNTIME_PLATFORM" != "null" ]; then
            REGISTER_ARGS="$REGISTER_ARGS --runtime-platform '$RUNTIME_PLATFORM'"
          fi

          # 6) Register the new revision
          NEW_TASK_DEF=$(aws ecs register-task-definition $REGISTER_ARGS)
          NEW_REVISION=$(echo "$NEW_TASK_DEF" | jq -r '.taskDefinition.revision')

          echo "New task definition revision: $NEW_REVISION"

          # 7) Update the ECS service to use the new revision
          aws ecs update-service \
            --cluster threatened-species-cluster \
            --service threatened-species-service \
            --task-definition "${TASK_FAMILY}:${NEW_REVISION}" \
            --force-new-deployment

          echo "Service updated to use task definition revision ${NEW_REVISION}."